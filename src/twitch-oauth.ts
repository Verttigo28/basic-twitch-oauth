/*!
 * basic-twitch-oauth
 * Copyright(c) 2019-present caLLowCreation
 * MIT Licensed
 */

import fetch, { Response } from 'node-fetch';
import { URLSearchParams } from 'url';

interface TwitchOAuthOptions {
	client_id: string,
	client_secret: string,
	redirect_uri: string,
	scopes: string[]
}

interface Authenticated {
	access_token: string,
	refresh_token: string,
	expires_in: number,
	expires_time: number
}

interface TokenOptions {
	access_token: string,
	refresh_token: string,
	expires_in: number
}

enum METHOD {
	GET = 'GET',
	POST = 'POST',
	PUT = 'PUT'
}

enum GRANT_TYPE {
	REFRESH_TOKEN = 'refresh_token',
	AUTHORIZATION_CODE = 'authorization_code'
}

const SECONDS_OFF: number = 60;
const DOMAIN: string = 'https://id.twitch.tv/oauth2';

const CONTENT_TYPE_JSON: string = 'application/json';

const ERROR_MESSAGES = {
	state: 'The response includes a state parameter error'
};

const EMPTY_AUTHENTICATED: Authenticated = {
	access_token: '',
	refresh_token: '',
	expires_in: 0,
	expires_time: 0
};

class TwitchOAuth {

	private oauthOptions: TwitchOAuthOptions;

	private state: string;

	private authenticated: Authenticated = EMPTY_AUTHENTICATED;

	constructor(oauthOptions: TwitchOAuthOptions, state: string) {
		this.oauthOptions = oauthOptions;
		this.state = state;
	}

	/**
	 * OAuth authorization code flow url
	 * 
	 * Use to initiate the oauth process
	 * 
	 */
	get authorizeUrl(): string {
		const urlParams = [
			`client_id=${this.oauthOptions.client_id}`,
			`redirect_uri=${encodeURIComponent(this.oauthOptions.redirect_uri)}`,
			`response_type=code`,
			`scope=${encodeURIComponent(this.oauthOptions.scopes.join(' '))}`,
			`state=${this.state}`
		];
		return `${DOMAIN}/authorize?${urlParams.join('&')}`;
	}

	/**
	 * 
	 * @param state Your unique token, generated by your application. 
	 * This is an OAuth 2.0 opaque value, used to avoid CSRF attacks. 
	 * This value is echoed back in the response. 
	 * We strongly recommend you use this.
	 * 
	 * @throws When state are not an exact match
	 * 
	 */
	confirmState(state: string): void {
		if (state !== this.state) {
			throw new Error(ERROR_MESSAGES.state);
		}
	}
	
	/**
	 * 
	 * @param code The code returned by response_type 'code' in the authorization redirect uri
	 * 
	 * @throws When request fails or jason parsing fails
	 * 
	 */
	async fetchToken(code: string): Promise<void> {
		return fetch(`${DOMAIN}/token`, {
			method: METHOD.POST,
			headers: this.getBasicHeaders(this.oauthOptions.client_id, this.oauthOptions.client_secret),
			body: new URLSearchParams({
				client_id: this.oauthOptions.client_id,
				client_secret: this.oauthOptions.client_secret,
				code: code,
				grant_type: GRANT_TYPE.AUTHORIZATION_CODE,
				redirect_uri: this.oauthOptions.redirect_uri
			})
		})
			.then(this.checkStatus)
			.then(this.toJson)
			.then(this.setAuthenticated.bind(this)); // Ratstail91 FTW .bind(this) fixed undefine 'this'
	}

	/**
	 * 
	 * @throws When request fails or jason parsing fails
	 * 
	 */
	async fetchRefreshToken(): Promise<void> {
		return fetch(`${DOMAIN}/token`, {
			method: METHOD.POST,
			headers: this.getBasicHeaders(this.oauthOptions.client_id, this.oauthOptions.client_secret),
			body: new URLSearchParams({
				client_id: this.oauthOptions.client_id,
				client_secret: this.oauthOptions.client_secret,
				grant_type: GRANT_TYPE.REFRESH_TOKEN,
				refresh_token: this.authenticated.refresh_token
			})
		})
			.then(this.checkStatus)
			.then(this.toJson)
			.then(this.setAuthenticated.bind(this)); // Ratstail91 FTW .bind(this) fixed undefine 'this'
	}

	/**
	 * 
	 * @param url Endpoint to make request
	 * 
	 * @throws When request fails or jason parsing fails
	 * 
	 */
	async getEndpoint(url: string): Promise<any> {
		await this.refreshTokenIfNeeded();
		return this.fetchEndpoint(url, METHOD.GET);
	}

	/**
	 * 
	 * @param url Endpoint to make request
	 * @param body JavaScript object to be send with the request
	 * 
	 * @throws When request fails or jason parsing fails
	 * 
	 */
	async postEndpoint(url: string, body: any): Promise<any> {
		await this.refreshTokenIfNeeded();
		return this.fetchEndpoint(url, METHOD.POST, body);
	}

	/**
	 * 
	 * @param url Endpoint to make request
	 * @param body JavaScript object to be send with the request
	 * 
	 * @throws When request fails or jason parsing fails
	 * 
	 */
	async putEndpoint(url: string, body: any): Promise<any> {
		await this.refreshTokenIfNeeded();
		return this.fetchEndpoint(url, METHOD.PUT, body);
	}

	private async refreshTokenIfNeeded(): Promise<void> {
		const date: Date = new Date();
		const seconds: number = Math.round(date.getTime() / 1000);
		if (seconds > this.authenticated.expires_time) {
			this.authenticated = EMPTY_AUTHENTICATED;
			await this.fetchRefreshToken();
		}
	}

	private fetchEndpoint(url: string, method: METHOD, body?: any): Promise<TokenOptions> {
		const options = {
			method: method,
			body: typeof body !== 'string' ? JSON.stringify(body) : body,
			headers: this.getBearerHeaders(this.oauthOptions.client_id, this.authenticated.access_token)
		};

		if(!body) delete options.body;

		return fetch(url, options)
			.then(this.checkStatus)
			.then(this.toResult);
	}

	private toJson(res: Response): Promise<TokenOptions> {
		return res.json();
	}

	private toResult(res: Response): Promise<any> {
		const contentType = res.headers.get('content-type') as string;
		return contentType && contentType.includes(CONTENT_TYPE_JSON) ? res.json() : res.text();
	}

	private checkStatus(res: Response): Response {
		if (res.ok) { // res.status >= 200 && res.status < 300
			return res;
		} else {
			throw new Error(res.statusText);
		}
	}

	private setAuthenticated(tokenOptions: TokenOptions): void {
		this.authenticated.access_token = tokenOptions.access_token;
		this.authenticated.refresh_token = tokenOptions.refresh_token;
		this.authenticated.expires_in = tokenOptions.expires_in;

		const date: Date = new Date();
		const seconds = Math.round(date.getTime() / 1000);
		this.authenticated.expires_time = (seconds + this.authenticated.expires_in) - SECONDS_OFF;
	}

	private getBasicHeaders(client_id: string, client_secret: string) {
		return {
			'Authorization': 'Basic ' + (Buffer.from(client_id + ':' + client_secret).toString('base64'))
		};
	}

	private getBearerHeaders(client_id: string, access_token: string) {
		return {
			'Authorization': 'Bearer ' + access_token,
			'Client-ID': client_id,
			'Content-Type': CONTENT_TYPE_JSON
		};
	}
}

export default TwitchOAuth;