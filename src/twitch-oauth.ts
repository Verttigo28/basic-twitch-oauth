/*!
 * basic-twitch-oauth
 * Copyright(c) 2019-present caLLowCreation
 * MIT Licensed
 */

import fetch, { Response } from 'node-fetch';
import { URLSearchParams } from 'url';

interface TwitchOAuthOptions {
	client_id: string,
	client_secret: string,
	redirect_uri: string,
	scopes: string[]
}

interface Authenticated {
	access_token: string,
	refresh_token: string,
	expires_in: number,
	expires_time: number
}

interface TokenOptions {
	access_token: string,
	refresh_token: string,
	expires_in: number
}

const SECONDS_OFF: number = 60;
const DOMAIN: string = 'https://id.twitch.tv/oauth2';


const EMPTY_AUTHENTICATED: Authenticated = {
	access_token: '',
	refresh_token: '',
	expires_in: 0,
	expires_time: 0
};

class TwitchOAuth {

	private oauthOptions: TwitchOAuthOptions;
	private state: string;

	private authenticated: Authenticated = EMPTY_AUTHENTICATED;

	constructor(oauthOptions: TwitchOAuthOptions, state: string) {
		this.oauthOptions = oauthOptions;
		this.state = state;
	}

	private get scopes(): string {
		return this.oauthOptions.scopes.join(' ');
	}

	get authorizeUrl(): string {
		const urlParams = [
			`client_id=${this.oauthOptions.client_id}`,
			`redirect_uri=${encodeURIComponent(this.oauthOptions.redirect_uri)}`,
			`response_type=code`,
			`scope=${encodeURIComponent(this.scopes)}`,
			`state=${this.state}`
		];
		return `${DOMAIN}/authorize?${urlParams.join('&')}`;
	}

	get isAuthenticated(): boolean {
		return this.authenticated.refresh_token !== '';
	}

	/**
	 * 
	 * @param state Your unique token, generated by your application. 
	 * This is an OAuth 2.0 opaque value, used to avoid CSRF attacks. 
	 * This value is echoed back in the response. 
	 * We strongly recommend you use this.
	 * 
	 * @throws When state are not an exact match
	 * 
	 */
	confirmState(state: string): void {
		if (state !== this.state) {
			throw new Error('The response includes the state parameter error');
		}
	}
	
	/**
	 * 
	 * @param code The code returned by response_type 'code' in the authorization redirect uri
	 * 
	 * @throws When request fails or jason parsing fails
	 * 
	 */
	async fetchToken(code: string): Promise<void> {
		return fetch(`${DOMAIN}/token`, {
			method: 'POST',
			headers: this.getBasicHeaders(this.oauthOptions.client_id, this.oauthOptions.client_secret),
			body: new URLSearchParams({
				client_id: this.oauthOptions.client_id,
				client_secret: this.oauthOptions.client_secret,
				code: code,
				grant_type: 'authorization_code',
				redirect_uri: this.oauthOptions.redirect_uri
			})
		})
			.then(this.checkStatus)
			.then(this.toJson)
			.then(this.setAuthenticated.bind(this))
			.catch(error => { throw error; });
	}

	/**
	 * 
	 * @throws When request fails or jason parsing fails
	 * 
	 */
	async fetchRefreshToken(): Promise<void> {
		return fetch(`${DOMAIN}/token`, {
			method: 'POST',
			headers: this.getBasicHeaders(this.oauthOptions.client_id, this.oauthOptions.client_secret),
			body: new URLSearchParams({
				client_id: this.oauthOptions.client_id,
				client_secret: this.oauthOptions.client_secret,
				grant_type: 'refresh_token',
				refresh_token: this.authenticated.refresh_token
			})
		})
			.then(this.checkStatus)
			.then(this.toJson)
			.then(this.setAuthenticated.bind(this))
			.catch(error => { throw error; });
	}

	private async refreshTokenIfNeeded(): Promise<void> {
		const date: Date = new Date();
		const seconds: number = Math.round(date.getTime() / 1000);
		if (seconds > this.authenticated.expires_time) {
			this.authenticated = EMPTY_AUTHENTICATED;
			await this.fetchRefreshToken().catch(error => { throw error; });
		}
	}

	/**
	 * 
	 * @param url Endpoint to make request
	 * 
	 * @throws When request fails or jason parsing fails
	 * 
	 */
	async getEndpoint(url: string): Promise<any> {
		await this.refreshTokenIfNeeded();
		return this.fetchEndpoint(url).catch(error => { throw error; });
	}

	private fetchEndpoint(url: string): Promise<TokenOptions> {
		return fetch(url, {
			method: 'GET',
			headers: this.getBearerHeaders(this.oauthOptions.client_id, this.authenticated.access_token)
		})
			.then(this.checkStatus)
			.then(this.toJson)
			.catch(error => { throw error; });
	}

	private toJson(res: Response): Promise<TokenOptions> {
		return res.json();
	}

	private checkStatus(res: Response): Response {
		if (res.ok) { // res.status >= 200 && res.status < 300
			return res;
		} else {
			throw new Error(res.statusText);
		}
	}

	private setAuthenticated(tokenOptions: TokenOptions): void {
		this.authenticated.access_token = tokenOptions.access_token;
		this.authenticated.refresh_token = tokenOptions.refresh_token;
		this.authenticated.expires_in = tokenOptions.expires_in;

		const date: Date = new Date();
		const seconds = Math.round(date.getTime() / 1000);
		this.authenticated.expires_time = (seconds + this.authenticated.expires_in) - SECONDS_OFF;
		console.log('Set Expires Time', this.authenticated.expires_time);
	}

	private getBasicHeaders(client_id: string, client_secret: string) {
		return {
			'Authorization': 'Basic ' + (Buffer.from(client_id + ':' + client_secret).toString('base64'))
		};
	}

	private getBearerHeaders(client_id: string, access_token: string) {
		return {
			'Authorization': 'Bearer ' + access_token,
			'Client-ID': client_id,
			'Content-Type': 'application/json'
		};
	}

}

export default TwitchOAuth;