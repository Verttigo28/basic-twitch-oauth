"use strict";
/*!
 * basic-twitch-oauth
 * Copyright(c) 2019-present caLLowCreation
 * MIT Licensed
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = __importDefault(require("node-fetch"));
const url_1 = require("url");
var METHOD;
(function (METHOD) {
    METHOD["GET"] = "GET";
    METHOD["POST"] = "POST";
    METHOD["PUT"] = "PUT";
})(METHOD || (METHOD = {}));
var GRANT_TYPE;
(function (GRANT_TYPE) {
    GRANT_TYPE["REFRESH_TOKEN"] = "refresh_token";
    GRANT_TYPE["AUTHORIZATION_CODE"] = "authorization_code";
})(GRANT_TYPE || (GRANT_TYPE = {}));
const SECONDS_OFF = 60;
const DOMAIN = 'https://id.twitch.tv/oauth2';
const CONTENT_TYPE_JSON = 'application/json';
const ERROR_MESSAGES = {
    state: 'The response includes a state parameter error'
};
const EMPTY_AUTHENTICATED = {
    access_token: '',
    refresh_token: '',
    expires_in: 0,
    expires_time: 0
};
class TwitchOAuth {
    constructor(oauthOptions, state) {
        this.authenticated = EMPTY_AUTHENTICATED;
        this.oauthOptions = oauthOptions;
        this.state = state;
    }
    /**
     * OAuth authorization code flow url
     *
     * Use to initiate the oauth process
     *
     */
    get authorizeUrl() {
        const urlParams = [
            `client_id=${this.oauthOptions.client_id}`,
            `redirect_uri=${encodeURIComponent(this.oauthOptions.redirect_uri)}`,
            `response_type=code`,
            `scope=${encodeURIComponent(this.oauthOptions.scopes.join(' '))}`,
            `state=${this.state}`
        ];
        return `${DOMAIN}/authorize?${urlParams.join('&')}`;
    }
    /**
     *
     * @param state Your unique token, generated by your application.
     * This is an OAuth 2.0 opaque value, used to avoid CSRF attacks.
     * This value is echoed back in the response.
     * We strongly recommend you use this.
     *
     * @throws When state are not an exact match
     *
     */
    confirmState(state) {
        if (state !== this.state) {
            throw new Error(ERROR_MESSAGES.state);
        }
    }
    /**
     *
     * @param code The code returned by response_type 'code' in the authorization redirect uri
     *
     * @throws When request fails or jason parsing fails
     *
     */
    async fetchToken(code) {
        return node_fetch_1.default(`${DOMAIN}/token`, {
            method: METHOD.POST,
            headers: this.getBasicHeaders(this.oauthOptions.client_id, this.oauthOptions.client_secret),
            body: new url_1.URLSearchParams({
                client_id: this.oauthOptions.client_id,
                client_secret: this.oauthOptions.client_secret,
                code: code,
                grant_type: GRANT_TYPE.AUTHORIZATION_CODE,
                redirect_uri: this.oauthOptions.redirect_uri
            })
        })
            .then(this.checkStatus)
            .then(this.toJson)
            .then(this.setAuthenticated.bind(this)); // Ratstail91 FTW .bind(this) fixed undefine 'this'
    }
    /**
     *
     * @throws When request fails or jason parsing fails
     *
     */
    async fetchRefreshToken() {
        return node_fetch_1.default(`${DOMAIN}/token`, {
            method: METHOD.POST,
            headers: this.getBasicHeaders(this.oauthOptions.client_id, this.oauthOptions.client_secret),
            body: new url_1.URLSearchParams({
                client_id: this.oauthOptions.client_id,
                client_secret: this.oauthOptions.client_secret,
                grant_type: GRANT_TYPE.REFRESH_TOKEN,
                refresh_token: this.authenticated.refresh_token
            })
        })
            .then(this.checkStatus)
            .then(this.toJson)
            .then(this.setAuthenticated.bind(this)); // Ratstail91 FTW .bind(this) fixed undefine 'this'
    }
    /**
     *
     * @param url Endpoint to make request
     *
     * @throws When request fails or jason parsing fails
     *
     */
    async getEndpoint(url) {
        await this.refreshTokenIfNeeded();
        return this.fetchEndpoint(url, METHOD.GET);
    }
    /**
     *
     * @param url Endpoint to make request
     * @param body JavaScript object to be send with the request
     *
     * @throws When request fails or jason parsing fails
     *
     */
    async postEndpoint(url, body) {
        await this.refreshTokenIfNeeded();
        return this.fetchEndpoint(url, METHOD.POST, body);
    }
    /**
     *
     * @param url Endpoint to make request
     * @param body JavaScript object to be send with the request
     *
     * @throws When request fails or jason parsing fails
     *
     */
    async putEndpoint(url, body) {
        await this.refreshTokenIfNeeded();
        return this.fetchEndpoint(url, METHOD.PUT, body);
    }
    async refreshTokenIfNeeded() {
        const date = new Date();
        const seconds = Math.round(date.getTime() / 1000);
        if (seconds > this.authenticated.expires_time) {
            this.authenticated = EMPTY_AUTHENTICATED;
            await this.fetchRefreshToken();
        }
    }
    fetchEndpoint(url, method, body) {
        const options = {
            method: method,
            body: typeof body !== 'string' ? JSON.stringify(body) : body,
            headers: this.getBearerHeaders(this.oauthOptions.client_id, this.authenticated.access_token)
        };
        if (!body)
            delete options.body;
        return node_fetch_1.default(url, options)
            .then(this.checkStatus)
            .then(this.toResult);
    }
    toJson(res) {
        return res.json();
    }
    toResult(res) {
        const contentType = res.headers.get('content-type');
        return contentType && contentType.includes(CONTENT_TYPE_JSON) ? res.json() : res.text();
    }
    checkStatus(res) {
        if (res.ok) { // res.status >= 200 && res.status < 300
            return res;
        }
        else {
            throw new Error(res.statusText);
        }
    }
    setAuthenticated(tokenOptions) {
        this.authenticated.access_token = tokenOptions.access_token;
        this.authenticated.refresh_token = tokenOptions.refresh_token;
        this.authenticated.expires_in = tokenOptions.expires_in;
        const date = new Date();
        const seconds = Math.round(date.getTime() / 1000);
        this.authenticated.expires_time = (seconds + this.authenticated.expires_in) - SECONDS_OFF;
    }
    getBasicHeaders(client_id, client_secret) {
        return {
            'Authorization': 'Basic ' + (Buffer.from(client_id + ':' + client_secret).toString('base64'))
        };
    }
    getBearerHeaders(client_id, access_token) {
        return {
            'Authorization': 'Bearer ' + access_token,
            'Client-ID': client_id,
            'Content-Type': CONTENT_TYPE_JSON
        };
    }
}
exports.default = TwitchOAuth;
//# sourceMappingURL=twitch-oauth.js.map